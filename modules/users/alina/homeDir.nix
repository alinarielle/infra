{config, lib, opt, cfg, ...}: {
  opt = with lib.types; lib.mkOption { default = {}; type = attrsOf (submodule {
    paths = lib.mkOption { default = {}; type = attrsOf path; };
    bucket = {
      cacheDir = lib.mkOption {
        type = nullOr path;
        default = "/persist/cache/rclone";
        description = ''
          the directory to use as VFS cache, will be created using systemd.tmpfiles.settings.
          make sure to put this on a fast storage disk on which you want to cache your files.
          set to null to not cache any files (not recommended)
        '';
      };
      provider = lib.mkOption {
        description = ''
          rclone requires you to specify the cloud provider you are using for your S3 bucket.
          use "Other" for tigris, b2 for backblaze etc. refer to https://rclone.org/s3/
        '';
        type = str;
        default = "Other";
      };
      readOnly = lib.mkEnableOption "make the home filesystem mount read only";
      accessKeyFile = lib.mkOption { 
        type = path; 
        default = null;
        description = "a path to a file containing the access key of your S3 bucket";
      };
      secretAccessKeyFile = lib.mkOption { 
        type = path; 
        default = null;
        description = "a path to a file containing the secret access key of your S3 bucket";
      };
      encryptedRemotePassphrase = lib.mkOption { 
        type = path;
        default = null; 
        description = ''
          a path to a file containing the obscured passphrase generated by rclone for the encrypted
          remote
        '';
      };
      encryptedRemoteSalt = lib.mkOption { 
        type = path; 
        default = null; 
        description = ''
          a path to a file containing the obscured salt generated by rclone for the encrypted remote
        '';
      };
      endpoint = lib.mkOption { 
        type = str; 
        default = null; 
        example = "https://t3.storage.dev";
        description = "a URL to the endpoint for your S3 bucket";
      };
      remoteDirectoryPrefix = lib.mkOption { 
        type = str; 
        default = ""; 
        description = ''
          here you can specify a subdirectory in the bucket to be used as storage 
          for your distributed home directory. "woof/" would put a path called "pictures" into 
          bucket:woof/pictures.
        '';
      };
    };
  }; ) };
  assertions = [{}];
  imports = [
    inputs.home-manager.nixosModules.home-manager
  ];

  systemd.tmpfiles.settings."vfsCache" = (lib.mapAttrs' (key: val: 
    lib.nameValuePair
      ("/persist/cache/rclone/" + key)
      { d = { user = key; group = key; type = "d"; age = "-"; mode = "0700"; }; }
  ) cfg) // {
    "/persist/cache/rclone".d = {
      user = "root"; group = "root"; type = "d"; age = "-"; mode = "0700";
    };
  };

  home-manager.users = lib.mapAttrs (key: val: {
    programs.rclone = {
      enable = true;
      remotes.homeDirBucket = {
        config = {
          provider = val.bucket.provider;
          endpoint = val.bucket.endpoint;
          type = "s3";
        };
        secrets = {
          secret_access_key = val.bucket.accessKeyFile;
          access_key_id = val.bucket.secretAccessKeyFile;
        };
      };
      remotes.encryptedHomeDirBucket = {
        config = {
          type = "crypt";
          remote = "homeDirBucket:${val.bucket.remoteDirectoryPrefix}";
        };
        mounts = mapAttrs (k: v: {
          enable = true;
          mountPoint = v;  
          options = {
            cache-dir = val.bucket.cacheDir + "/${key}"; # use this directory as VFS cache
            vfs-cache-mode = "full"; # cache everything
            vfs-cache-max-age = "off"; # dont remove stale objects from cache
            vfs-cache-max-size = "10G"; # objects in cache are allowed to have a maximum size of 10GB
            vfs-cache-min-free-space = "100G";  # make sure there is still 100GB of storage space available 
                                                # on the disk used for caching
            vfs-cache-poll-interval = "5s"; # poll for new files every 5 seconds ?
            vfs-write-back = "5s"; # write files from cache layer to remote 5 seconds after it has been closed
            vfs-fast-fingerprint = true; # dont query slow file metadata for faster syncs, is less accurate
            #buffer-size = ""; # ???
            #vfs-read-ahead = ""; # extra read ahead over --buffer-size when using cache-mode full
            vfs-read-chunk-size = "4M"; # size of read-ahead chunks
            vfs-read-chunk-size-limit = "off";  # if greater than --vfs-read-chunk-size, double the chunk size after 
                                                # each chunk read, until the limit is reached ('off' is unlimited)
            vfs-read-chunk-streams = 16; # number of concurrent read ahead chunk downloads (per file?)
            vfs-refresh = true; # refreshes the directory cache recursively in the background on start
            links = true; # enable support for symlinks
            vfs-links = true; # enable support for symlinks in the VFS caching layer
            transfers = 4; # the number of concurrent file uploads from cache
            #vfs-used-is-size = true; # may be very expensive due to excessive API calls for rclone size in S3 backends
            vfs-write-back = "1s"; # time to write back files from cache after they have been last used
            write-back-cache = true;  # makes kernel buffer writes before sending them to rclone 
                                      # (without this, writethrough caching is used)
            allow-non-empty = true; # allow mounting over a non-empty directory
            allow-root = true; # allow access to root user
            async-read = true; # use asyncronous reads
            attr-timeout = "1s"; # cache file attributes for 1 second in the kernel to avoid excessive callbacks to rclone
            default-permissions = true; # makes kernel enforce access control based on the file mode
            dir-perms = "700"; # unix perms for directories
            file-perms = "600"; # unix perms for files
            link-perms = "600"; # unix perms for symlinks
            dir-cache-time = "5m0s"; # time to cache directories for
            poll-interval = "5s"; # time to wait between polling for changes, must be smaller than dir-cache-time
          } // lib.mkIf val.readOnly { read-only = true; };
          secrets = {
            password = val.bucket.encryptedRemotePassphrase;
            password2 = val.bucket.encryptedRemoteSalt;
          };
        }) val.paths;
      };
    };
  }) cfg;
}
# TODO generate performance metrics with iperf and automatically adjust VFS caching accordingly
